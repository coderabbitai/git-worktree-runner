#!/bin/sh
# gtr - Git worktree runner
# Portable, cross-platform git worktree management

set -e

# Version
GTR_VERSION="1.0.0"

# Find the script directory
GTR_DIR="$(cd "$(dirname "$0")/.." && pwd)"

# Source library files
. "$GTR_DIR/lib/ui.sh"
. "$GTR_DIR/lib/config.sh"
. "$GTR_DIR/lib/platform.sh"
. "$GTR_DIR/lib/core.sh"
. "$GTR_DIR/lib/copy.sh"
. "$GTR_DIR/lib/hooks.sh"

# Main dispatcher
main() {
  local cmd="${1:-help}"
  shift 2>/dev/null || true

  case "$cmd" in
    new)
      cmd_create "$@"
      ;;
    rm)
      cmd_remove "$@"
      ;;
    go)
      cmd_go "$@"
      ;;
    open)
      cmd_open "$@"
      ;;
    ai)
      cmd_ai "$@"
      ;;
    ls|list)
      cmd_list "$@"
      ;;
    clean)
      cmd_clean "$@"
      ;;
    doctor)
      cmd_doctor "$@"
      ;;
    adapter|adapters)
      cmd_adapter "$@"
      ;;
    config)
      cmd_config "$@"
      ;;
    version|--version|-v)
      echo "gtr version $GTR_VERSION"
      ;;
    help|--help|-h)
      cmd_help
      ;;
    *)
      log_error "Unknown command: $cmd"
      echo "Use 'gtr help' for available commands"
      exit 1
      ;;
  esac
}

# Create command
cmd_create() {
  local worktree_id=""
  local branch_name=""
  local from_ref=""
  local track_mode="auto"
  local editor=""
  local ai_tool=""
  local explicit_id=0
  local skip_copy=0
  local skip_fetch=0
  local yes_mode=0

  # Parse flags and arguments
  while [ $# -gt 0 ]; do
    case "$1" in
      --id)
        worktree_id="$2"
        explicit_id=1
        shift 2
        ;;
      --from)
        from_ref="$2"
        shift 2
        ;;
      --track)
        track_mode="$2"
        shift 2
        ;;
      --editor)
        case "${2-}" in
          --*|"")
            editor="$(cfg_default gtr.editor.default GTR_EDITOR_DEFAULT none)"
            shift 1
            ;;
          *)
            editor="$2"
            shift 2
            ;;
        esac
        ;;
      --ai)
        case "${2-}" in
          --*|"")
            ai_tool="$(cfg_default gtr.ai.default GTR_AI_DEFAULT none)"
            shift 1
            ;;
          *)
            ai_tool="$2"
            shift 2
            ;;
        esac
        ;;
      --no-copy)
        skip_copy=1
        shift
        ;;
      --no-fetch)
        skip_fetch=1
        shift
        ;;
      --yes)
        yes_mode=1
        shift
        ;;
      -*)
        log_error "Unknown flag: $1"
        exit 1
        ;;
      *)
        # Positional argument: treat as branch name
        if [ -z "$branch_name" ]; then
          branch_name="$1"
        fi
        shift
        ;;
    esac
  done

  # Get repo info
  local repo_root
  repo_root=$(discover_repo_root) || exit 1

  local base_dir prefix start_id
  base_dir=$(resolve_base_dir "$repo_root")
  prefix=$(cfg_default gtr.worktrees.prefix GTR_WORKTREES_PREFIX "wt-")
  start_id=$(cfg_default gtr.worktrees.startId GTR_WORKTREES_STARTID "2")

  # Auto-assign ID if not explicitly provided (NEW DEFAULT BEHAVIOR)
  if [ "$explicit_id" -eq 0 ]; then
    worktree_id=$(next_available_id "$base_dir" "$prefix" "$start_id")
  fi

  # Get branch name if not provided
  if [ -z "$branch_name" ]; then
    if [ "$yes_mode" -eq 1 ]; then
      log_error "Branch name required in non-interactive mode"
      exit 1
    fi
    branch_name=$(prompt_input "Enter branch name for worktree ${prefix}${worktree_id}:")
    if [ -z "$branch_name" ]; then
      log_error "Branch name required"
      exit 1
    fi
  fi

  # Determine from_ref
  if [ -z "$from_ref" ]; then
    from_ref=$(resolve_default_branch "$repo_root")
  fi

  local worktree_path
  worktree_path="$base_dir/${prefix}${worktree_id}"

  log_step "Creating worktree: ${prefix}${worktree_id}"
  echo "üìÇ Location: $worktree_path"
  echo "üåø Branch: $branch_name"

  # Create the worktree
  if ! create_worktree "$base_dir" "$prefix" "$worktree_id" "$branch_name" "$from_ref" "$track_mode" "$skip_fetch"; then
    exit 1
  fi

  # Copy files based on patterns
  if [ "$skip_copy" -eq 0 ]; then
    local includes excludes
    includes=$(cfg_get_all gtr.copy.include)
    excludes=$(cfg_get_all gtr.copy.exclude)

    if [ -n "$includes" ]; then
      log_step "Copying files..."
      copy_patterns "$repo_root" "$worktree_path" "$includes" "$excludes"
    fi
  fi

  # Run post-create hooks
  run_hooks_in postCreate "$worktree_path" \
    REPO_ROOT="$repo_root" \
    WORKTREE_PATH="$worktree_path" \
    BRANCH="$branch_name"

  # Open in editor if requested or if default is configured
  if [ -z "$editor" ]; then
    # No explicit --editor flag, check for default
    editor=$(cfg_default gtr.editor.default GTR_EDITOR_DEFAULT "none")
  fi

  if [ -n "$editor" ] && [ "$editor" != "none" ]; then
    load_editor_adapter "$editor"
    if editor_can_open; then
      log_step "Opening in $editor..."
      editor_open "$worktree_path"
    fi
  fi

  # Start AI tool if requested or if default is configured
  if [ -z "$ai_tool" ]; then
    # No explicit --ai flag, check for default
    ai_tool=$(cfg_default gtr.ai.default GTR_AI_DEFAULT "none")
  fi

  if [ -n "$ai_tool" ] && [ "$ai_tool" != "none" ]; then
    load_ai_adapter "$ai_tool"
    if ai_can_start; then
      log_step "Starting $ai_tool..."
      ai_start "$worktree_path"
    fi
  fi

  echo ""
  log_info "Worktree created successfully!"
  echo "üéØ Navigate with: cd $worktree_path"
  echo "üìÇ Open with: gtr open $worktree_id"
  echo "ü§ñ Start AI with: gtr ai $worktree_id"
}

# Remove command
cmd_remove() {
  local delete_branch=0
  local yes_mode=0
  local force=0
  local identifiers=""

  # Parse flags
  while [ $# -gt 0 ]; do
    case "$1" in
      --delete-branch)
        delete_branch=1
        shift
        ;;
      --yes)
        yes_mode=1
        shift
        ;;
      --force)
        force=1
        shift
        ;;
      -*)
        log_error "Unknown flag: $1"
        exit 1
        ;;
      *)
        identifiers="$identifiers $1"
        shift
        ;;
    esac
  done

  if [ -z "$identifiers" ]; then
    log_error "Usage: gtr rm <id|branch> [<id|branch>...] [--delete-branch] [--force] [--yes]"
    exit 1
  fi

  local repo_root base_dir prefix
  repo_root=$(discover_repo_root) || exit 1
  base_dir=$(resolve_base_dir "$repo_root")
  prefix=$(cfg_default gtr.worktrees.prefix GTR_WORKTREES_PREFIX "wt-")

  for identifier in $identifiers; do
    # Resolve target (supports both ID and branch name)
    local target worktree_id worktree_path branch_name
    target=$(resolve_target "$identifier" "$repo_root" "$base_dir" "$prefix") || continue
    worktree_id=$(echo "$target" | cut -f1)
    worktree_path=$(echo "$target" | cut -f2)
    branch_name=$(echo "$target" | cut -f3)

    # Cannot remove ID 1 (main repository)
    if [ "$worktree_id" = "1" ]; then
      log_error "Cannot remove main repository (ID 1)"
      continue
    fi

    log_step "Removing worktree: ${prefix}${worktree_id} (branch: $branch_name)"

    # Remove the worktree
    if ! remove_worktree "$worktree_path" "$force"; then
      continue
    fi

    # Handle branch deletion
    if [ -n "$branch_name" ]; then
      if [ "$delete_branch" -eq 1 ]; then
        if [ "$yes_mode" -eq 1 ] || prompt_yes_no "Also delete branch '$branch_name'?"; then
          if git branch -D "$branch_name" 2>/dev/null; then
            log_info "Branch deleted: $branch_name"
          else
            log_warn "Could not delete branch: $branch_name"
          fi
        fi
      fi
    fi

    # Run post-remove hooks
    run_hooks postRemove \
      REPO_ROOT="$repo_root" \
      WORKTREE_PATH="$worktree_path" \
      BRANCH="$branch_name"
  done
}

# Go command (navigate to worktree - prints path for shell integration)
cmd_go() {
  if [ $# -ne 1 ]; then
    log_error "Usage: gtr go <id|branch>"
    exit 1
  fi

  local identifier="$1"
  local repo_root base_dir prefix
  repo_root=$(discover_repo_root) || exit 1
  base_dir=$(resolve_base_dir "$repo_root")
  prefix=$(cfg_default gtr.worktrees.prefix GTR_WORKTREES_PREFIX "wt-")

  # Resolve target (supports both ID and branch name)
  local target worktree_id worktree_path branch
  target=$(resolve_target "$identifier" "$repo_root" "$base_dir" "$prefix") || exit 1
  worktree_id=$(echo "$target" | cut -f1)
  worktree_path=$(echo "$target" | cut -f2)
  branch=$(echo "$target" | cut -f3)

  # Human messages to stderr so stdout can be used in command substitution
  if [ "$worktree_id" = "1" ]; then
    echo "üìÇ Repo root (id 1)" >&2
  else
    echo "üìÇ Worktree ${prefix}${worktree_id}" >&2
  fi
  echo "üåø Branch: $branch" >&2

  # Print path to stdout for shell integration: cd "$(gtr go 2)"
  printf "%s\n" "$worktree_path"
}

# Open command
cmd_open() {
  local editor=""
  local identifier=""

  # Parse arguments
  while [ $# -gt 0 ]; do
    case "$1" in
      --editor)
        editor="$2"
        shift 2
        ;;
      -*)
        log_error "Unknown flag: $1"
        exit 1
        ;;
      *)
        identifier="$1"
        shift
        ;;
    esac
  done

  if [ -z "$identifier" ]; then
    log_error "Usage: gtr open <id|branch> [--editor <editor>]"
    exit 1
  fi

  # Get editor from config if not specified
  if [ -z "$editor" ]; then
    editor=$(cfg_default gtr.editor.default GTR_EDITOR_DEFAULT "none")
  fi

  local repo_root base_dir prefix
  repo_root=$(discover_repo_root) || exit 1
  base_dir=$(resolve_base_dir "$repo_root")
  prefix=$(cfg_default gtr.worktrees.prefix GTR_WORKTREES_PREFIX "wt-")

  # Resolve target (supports both ID and branch name)
  local target worktree_id worktree_path branch
  target=$(resolve_target "$identifier" "$repo_root" "$base_dir" "$prefix") || exit 1
  worktree_id=$(echo "$target" | cut -f1)
  worktree_path=$(echo "$target" | cut -f2)
  branch=$(echo "$target" | cut -f3)

  if [ "$editor" = "none" ]; then
    # Just open in GUI file browser
    open_in_gui "$worktree_path"
    log_info "Opened in file browser"
  else
    # Load editor adapter and open
    load_editor_adapter "$editor"
    log_step "Opening in $editor..."
    editor_open "$worktree_path"
  fi
}

# AI command
cmd_ai() {
  local ai_tool=""
  local identifier=""
  local ai_args=""

  # Parse arguments
  while [ $# -gt 0 ]; do
    case "$1" in
      --tool)
        ai_tool="$2"
        shift 2
        ;;
      --)
        shift
        ai_args="$*"
        break
        ;;
      -*)
        log_error "Unknown flag: $1"
        exit 1
        ;;
      *)
        if [ -z "$identifier" ]; then
          identifier="$1"
        fi
        shift
        ;;
    esac
  done

  if [ -z "$identifier" ]; then
    log_error "Usage: gtr ai <id|branch> [--tool <tool>] [-- args...]"
    exit 1
  fi

  # Get AI tool from config if not specified
  if [ -z "$ai_tool" ]; then
    ai_tool=$(cfg_default gtr.ai.default GTR_AI_DEFAULT "none")
  fi

  # Check if AI tool is configured
  if [ "$ai_tool" = "none" ]; then
    log_error "No AI tool configured"
    log_info "Set default: gtr config set gtr.ai.default aider"
    log_info "Or use: gtr ai $identifier --tool aider"
    exit 1
  fi

  # Load AI adapter
  load_ai_adapter "$ai_tool"

  local repo_root base_dir prefix
  repo_root=$(discover_repo_root) || exit 1
  base_dir=$(resolve_base_dir "$repo_root")
  prefix=$(cfg_default gtr.worktrees.prefix GTR_WORKTREES_PREFIX "wt-")

  # Resolve target (supports both ID and branch name)
  local target worktree_id worktree_path branch
  target=$(resolve_target "$identifier" "$repo_root" "$base_dir" "$prefix") || exit 1
  worktree_id=$(echo "$target" | cut -f1)
  worktree_path=$(echo "$target" | cut -f2)
  branch=$(echo "$target" | cut -f3)

  log_step "Starting $ai_tool in worktree: ${prefix}${worktree_id}"
  echo "üìÇ Directory: $worktree_path"
  echo "üåø Branch: $branch"

  # shellcheck disable=SC2086
  ai_start "$worktree_path" $ai_args
}

# List command
cmd_list() {
  local porcelain=0
  local ids_only=0

  # Parse flags
  while [ $# -gt 0 ]; do
    case "$1" in
      --porcelain)
        porcelain=1
        shift
        ;;
      --ids)
        ids_only=1
        shift
        ;;
      *)
        shift
        ;;
    esac
  done

  local repo_root base_dir prefix
  repo_root=$(discover_repo_root) 2>/dev/null || return 0
  base_dir=$(resolve_base_dir "$repo_root")
  prefix=$(cfg_default gtr.worktrees.prefix GTR_WORKTREES_PREFIX "wt-")

  # IDs only (for completions)
  if [ "$ids_only" -eq 1 ]; then
    # Always include ID 1 (repo root)
    echo "1"

    if [ -d "$base_dir" ]; then
      find "$base_dir" -maxdepth 1 -type d -name "${prefix}*" 2>/dev/null | while IFS= read -r dir; do
        basename "$dir" | sed "s/^${prefix}//"
      done | sort -n
    fi
    return 0
  fi

  # Machine-readable output (porcelain)
  if [ "$porcelain" -eq 1 ]; then
    # Always include ID 1 (repo root)
    local branch
    branch=$(git -C "$repo_root" branch --show-current 2>/dev/null)
    [ -z "$branch" ] && branch="(detached)"
    printf "%s\t%s\t%s\t%s\n" "1" "$repo_root" "$branch" "ok"

    if [ -d "$base_dir" ]; then
      # Find all worktree directories and output: id<tab>path<tab>branch<tab>status
      find "$base_dir" -maxdepth 1 -type d -name "${prefix}*" 2>/dev/null | while IFS= read -r dir; do
        local id branch
        id=$(basename "$dir" | sed "s/^${prefix}//")
        branch=$(current_branch "$dir")
        [ -z "$branch" ] && branch="(detached)"
        printf "%s\t%s\t%s\t%s\n" "$id" "$dir" "$branch" "ok"
      done | sort -t$'\t' -k1 -n
    fi
    return 0
  fi

  # Human-readable output - table format
  echo "üìã Git Worktrees"
  echo ""
  printf "%-6s %-25s %s\n" "ID" "BRANCH" "PATH"
  printf "%-6s %-25s %s\n" "‚îÄ‚îÄ" "‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ" "‚îÄ‚îÄ‚îÄ‚îÄ"

  # Always show repo root as ID 1
  local branch
  branch=$(git -C "$repo_root" branch --show-current 2>/dev/null)
  [ -z "$branch" ] && branch="(detached)"
  printf "%-6s %-25s %s\n" "1" "$branch" "$repo_root"

  # Show worktrees
  if [ -d "$base_dir" ]; then
    find "$base_dir" -maxdepth 1 -type d -name "${prefix}*" 2>/dev/null | while IFS= read -r dir; do
      local id branch
      id=$(basename "$dir" | sed "s/^${prefix}//")
      branch=$(current_branch "$dir")
      [ -z "$branch" ] && branch="(detached)"
      printf "%-6s %-25s %s\n" "$id" "$branch" "$dir"
    done | sort -t' ' -k1 -n
  fi

  echo ""
  echo "üí° Tip: Use 'gtr list --porcelain' for machine-readable output"
}

# Clean command (remove prunable worktrees)
cmd_clean() {
  log_step "Cleaning up stale worktrees..."

  # Run git worktree prune
  if git worktree prune 2>/dev/null; then
    log_info "Pruned stale worktree administrative files"
  fi

  local repo_root base_dir prefix
  repo_root=$(discover_repo_root) || exit 1
  base_dir=$(resolve_base_dir "$repo_root")
  prefix=$(cfg_default gtr.worktrees.prefix GTR_WORKTREES_PREFIX "wt-")

  if [ ! -d "$base_dir" ]; then
    log_info "No worktrees directory to clean"
    return 0
  fi

  # Find and remove empty directories
  local cleaned=0
  find "$base_dir" -maxdepth 1 -type d -empty 2>/dev/null | while IFS= read -r dir; do
    if [ "$dir" != "$base_dir" ]; then
      rmdir "$dir" 2>/dev/null && cleaned=$((cleaned + 1))
      log_info "Removed empty directory: $(basename "$dir")"
    fi
  done

  log_info "‚úÖ Cleanup complete"
}

# Doctor command (health check)
cmd_doctor() {
  echo "üè• Running gtr health check..."
  echo ""

  local issues=0

  # Check git
  if command -v git >/dev/null 2>&1; then
    local git_version
    git_version=$(git --version)
    echo "‚úÖ Git: $git_version"
  else
    echo "‚ùå Git: not found"
    issues=$((issues + 1))
  fi

  # Check repo
  local repo_root
  if repo_root=$(discover_repo_root 2>/dev/null); then
    echo "‚úÖ Repository: $repo_root"

    # Check worktree base dir
    local base_dir prefix
    base_dir=$(resolve_base_dir "$repo_root")
    prefix=$(cfg_default gtr.worktrees.prefix GTR_WORKTREES_PREFIX "wt-")

    if [ -d "$base_dir" ]; then
      local count
      count=$(find "$base_dir" -maxdepth 1 -type d -name "${prefix}*" 2>/dev/null | wc -l | tr -d ' ')
      echo "‚úÖ Worktrees directory: $base_dir ($count worktrees)"
    else
      echo "‚ÑπÔ∏è  Worktrees directory: $base_dir (not created yet)"
    fi
  else
    echo "‚ùå Not in a git repository"
    issues=$((issues + 1))
  fi

  # Check configured editor
  local editor
  editor=$(cfg_default gtr.editor.default GTR_EDITOR_DEFAULT "none")
  if [ "$editor" != "none" ]; then
    if command -v "$editor" >/dev/null 2>&1; then
      echo "‚úÖ Editor: $editor (found)"
    else
      echo "‚ö†Ô∏è  Editor: $editor (configured but not found in PATH)"
    fi
  else
    echo "‚ÑπÔ∏è  Editor: none configured"
  fi

  # Check configured AI tool
  local ai_tool
  ai_tool=$(cfg_default gtr.ai.default GTR_AI_DEFAULT "none")
  if [ "$ai_tool" != "none" ]; then
    # Check if adapter exists
    local adapter_file="$GTR_DIR/adapters/ai/${ai_tool}.sh"
    if [ -f "$adapter_file" ]; then
      . "$adapter_file"
      if ai_can_start 2>/dev/null; then
        echo "‚úÖ AI tool: $ai_tool (found)"
      else
        echo "‚ö†Ô∏è  AI tool: $ai_tool (configured but not found in PATH)"
      fi
    else
      echo "‚ö†Ô∏è  AI tool: $ai_tool (adapter not found)"
    fi
  else
    echo "‚ÑπÔ∏è  AI tool: none configured"
  fi

  # Check OS
  local os
  os=$(detect_os)
  echo "‚úÖ Platform: $os"

  echo ""
  if [ "$issues" -eq 0 ]; then
    echo "üéâ Everything looks good!"
    return 0
  else
    echo "‚ö†Ô∏è  Found $issues issue(s)"
    return 1
  fi
}

# Adapter command (list available adapters)
cmd_adapter() {
  echo "üîå Available Adapters"
  echo ""

  # Editor adapters
  echo "üìù Editor Adapters:"
  echo ""
  printf "%-15s %-10s %s\n" "NAME" "STATUS" "NOTES"
  printf "%-15s %-10s %s\n" "‚îÄ‚îÄ‚îÄ‚îÄ" "‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ" "‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ"

  for adapter_file in "$GTR_DIR"/adapters/editor/*.sh; do
    if [ -f "$adapter_file" ]; then
      local adapter_name
      adapter_name=$(basename "$adapter_file" .sh)
      . "$adapter_file"

      if command -v "$adapter_name" >/dev/null 2>&1; then
        printf "%-15s %-10s %s\n" "$adapter_name" "‚úÖ ready" ""
      else
        printf "%-15s %-10s %s\n" "$adapter_name" "‚ö†Ô∏è  missing" "Install from $adapter_name.com"
      fi
    fi
  done

  echo ""
  echo "ü§ñ AI Tool Adapters:"
  echo ""
  printf "%-15s %-10s %s\n" "NAME" "STATUS" "NOTES"
  printf "%-15s %-10s %s\n" "‚îÄ‚îÄ‚îÄ‚îÄ" "‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ" "‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ"

  for adapter_file in "$GTR_DIR"/adapters/ai/*.sh; do
    if [ -f "$adapter_file" ]; then
      local adapter_name
      adapter_name=$(basename "$adapter_file" .sh)
      . "$adapter_file"

      if ai_can_start 2>/dev/null; then
        printf "%-15s %-10s %s\n" "$adapter_name" "‚úÖ ready" ""
      else
        printf "%-15s %-10s %s\n" "$adapter_name" "‚ö†Ô∏è  missing" "Not found in PATH"
      fi
    fi
  done

  echo ""
  echo "üí° Tip: Set defaults with:"
  echo "   gtr config set gtr.editor.default <name>"
  echo "   gtr config set gtr.ai.default <name>"
}

# Config command
cmd_config() {
  local action="${1:-get}"
  local key="$2"
  local value="$3"
  local scope="local"

  # Check for --global flag
  if [ "$key" = "--global" ] || [ "$value" = "--global" ]; then
    scope="global"
    [ "$key" = "--global" ] && key="$3" && value="$4"
    [ "$value" = "--global" ] && value="$4"
  fi

  case "$action" in
    get)
      if [ -z "$key" ]; then
        log_error "Usage: gtr config get <key> [--global]"
        exit 1
      fi
      cfg_get "$key" "$scope"
      ;;
    set)
      if [ -z "$key" ] || [ -z "$value" ]; then
        log_error "Usage: gtr config set <key> <value> [--global]"
        exit 1
      fi
      cfg_set "$key" "$value" "$scope"
      log_info "Config set: $key = $value"
      ;;
    unset)
      if [ -z "$key" ]; then
        log_error "Usage: gtr config unset <key> [--global]"
        exit 1
      fi
      cfg_unset "$key" "$scope"
      log_info "Config unset: $key"
      ;;
    *)
      log_error "Unknown config action: $action"
      log_error "Usage: gtr config {get|set|unset} <key> [value] [--global]"
      exit 1
      ;;
  esac
}

# Load editor adapter
load_editor_adapter() {
  local editor="$1"
  local adapter_file="$GTR_DIR/adapters/editor/${editor}.sh"

  if [ ! -f "$adapter_file" ]; then
    log_error "Unknown editor: $editor"
    log_info "Available editors: cursor, vscode, zed"
    exit 1
  fi

  . "$adapter_file"
}

# Load AI adapter
load_ai_adapter() {
  local ai_tool="$1"
  local adapter_file="$GTR_DIR/adapters/ai/${ai_tool}.sh"

  if [ ! -f "$adapter_file" ]; then
    log_error "Unknown AI tool: $ai_tool"
    log_info "Available AI tools: aider, claudecode, codex, cursor, continue"
    exit 1
  fi

  . "$adapter_file"
}

# Help command
cmd_help() {
  cat <<'EOF'
gtr - Git worktree runner

Run from within a git repository. Each repo has independent worktrees and IDs.

USAGE:
  cd ~/your-repo      # Navigate to git repo first
  gtr <command> [options]

COMMANDS:
  new <branch> [options]
         Create a new worktree (auto-assigns ID by default)
         --id <n>: specify exact ID (rarely needed)
         --from <ref>: create from specific ref
         --track <mode>: tracking mode (auto|remote|local|none)
         --editor <name>: override default editor
         --ai <tool>: override default AI tool
         --no-copy: skip file copying
         --no-fetch: skip git fetch
         --yes: non-interactive mode

  go <id|branch>
         Navigate to worktree (prints path for: cd "$(gtr go 2)")
         Accepts either numeric ID or branch name

  open <id|branch> [--editor <name>]
         Open worktree in editor or file browser
         Uses gtr.editor.default if not specified

  ai <id|branch> [--tool <name>] [-- args...]
         Start AI coding tool in worktree
         Uses gtr.ai.default if not specified

  rm <id> [<id>...] [options]
         Remove worktree(s)
         --delete-branch: also delete the branch
         --force: force removal (dirty worktree)
         --yes: skip confirmation

  ls, list [--porcelain|--ids]
         List all worktrees (ID 1 = repo root)

  clean
         Remove stale/prunable worktrees

  doctor
         Health check (verify git, editors, AI tools)

  adapter
         List available editor & AI tool adapters

  config {get|set|unset} <key> [value] [--global]
         Manage configuration

  version
         Show version

  help
         Show this help

EXAMPLES:
  # Navigate to your git repo first
  cd ~/GitHub/my-project

  # Simplest: create with branch name (auto-assigns ID)
  gtr new my-feature

  # Configure defaults (one-time setup per repo)
  gtr config set gtr.editor.default cursor
  gtr config set gtr.ai.default aider

  # Then use without flags (uses defaults)
  gtr open 2          # Opens in cursor (from config)
  gtr ai 2            # Starts aider (from config)

  # Or override defaults
  gtr open my-feature --editor vscode
  gtr ai my-feature --tool claudecode

  # Navigate by ID or branch name
  gtr go 2
  gtr go my-feature
  cd "$(gtr go my-feature)"

  # Create and open in editor
  gtr new ui-update --editor cursor --ai aider

  # Remove with branch deletion
  gtr rm 2 --delete-branch --yes

  # Health check
  gtr doctor

CONFIGURATION:
  gtr.worktrees.dir        Worktrees base directory
  gtr.worktrees.prefix     Worktree name prefix (default: wt-)
  gtr.worktrees.startId    Starting ID (default: 2)
  gtr.defaultBranch        Default branch (default: auto)
  gtr.editor.default       Default editor (cursor, vscode, zed, none)
  gtr.ai.default           Default AI tool (aider, claudecode, codex, cursor, continue, none)
  gtr.copy.include         Files to copy (multi-valued)
  gtr.copy.exclude         Files to exclude (multi-valued)
  gtr.hook.postCreate      Post-create hooks (multi-valued)
  gtr.hook.postRemove      Post-remove hooks (multi-valued)

See https://github.com/anthropics/git-worktree-runner for more info.
EOF
}

# Run main
main "$@"
